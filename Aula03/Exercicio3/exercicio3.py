# -*- coding: utf-8 -*-
"""Exercicio3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15JSMNhFbfcH-12By_7oALt0fvwJGd5XL
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
from statistics import mean

dataset1 = pd.read_csv('./Aula3-dataset_1.csv')
dataset2 = pd.read_csv('./Aula3-dataset_2.csv')

dataset1.plot('V1', 'V2', kind='scatter', c='V3', colormap='RdBu')

dataset1.head()

X1 = dataset1.iloc[:, :-1].values

def predict(row, weights):
    return sum(row * weights)

def sigmoid(result):
    return 1 / (1 + math.exp(-result))

def calculate_distance(points):
  distance = 0

  for point in points:
    for other in points:
      if other is not point:
        distance += np.linalg.norm(point-other)

  return distance

def perceptron(X, learning_rate=0.01):
    not_increase_count = 0
    X = np.append(X, np.ones(X.shape[0]).reshape(X.shape[0], -1), axis=1)
    weights = np.random.uniform(-1, 1, X.shape[1])
    distances = []
    window_size = 10
    
    distance = 1
    while True:
        outputs = np.array([])
        distance = 0.0
        
        data = X[np.random.choice(X.shape[0], X.shape[0], replace=False)]
        for i in range(X.shape[0]):
            result = predict(X[i], weights)
            prediction = sigmoid(result)
            output = 2 if prediction >= 0.5 else 1
            outputs = np.append(outputs, output)
            for j in range(X.shape[1]):
              X_mean = 0
              Y_mean = 0
              if i > window_size:
                X_mean = mean(X[i-window_size:i, j].tolist())
                Y_mean = mean(outputs[i-window_size: i])

              weights[j] = weights[j] + (learning_rate * (X[i, j] - X_mean) * (prediction-Y_mean))
        
        distance = calculate_distance(X[outputs == 2])
        distance += calculate_distance(X[outputs == 1])
        distances.append(distance)

        if len(distances) > 1 and distance >= distances[-2]:
          not_increase_count += 1
        else:
          not_increase_count = 0

        print(not_increase_count)
        if not_increase_count == 5:
          break

    return weights, distances

weights, distances = perceptron(X1, learning_rate=1e-3)
print(weights)

plt.plot(distances)

X2 = dataset2.iloc[:, :-1].values

weights, distances = perceptron(X2, learning_rate=1e-3)
plt.plot(distances)